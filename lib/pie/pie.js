(function() {
  var CoffeeScript, Mapping, Task, Watcher, async, cleanAllMappings, compilers, evaluatePiefile, fs, fsWatchTree, getMtime, glob, growl, handleMappingWatchEvent, invoke, load, map, minimatch, nStore, noop, option, optparse, path, printErr, rm, runAllMappings, shortErr, task, util, watch, watchMappings, _, _db, _mappings, _mappingsWatcher, _switches, _tasks,
    __slice = [].slice,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  fs = require("node-fs");

  path = require("path");

  util = require("util");

  async = require("async");

  CoffeeScript = require("coffee-script");

  glob = require("glob");

  minimatch = require("minimatch");

  fsWatchTree = require("fs-watch-tree");

  nStore = require("nstore");

  growl = require("growl");

  compilers = require("./compilers");

  optparse = require("./optparse");

  _ = require("underscore");

  _switches = [];

  _tasks = {};

  _mappings = [];

  _mappingsWatcher = null;

  _db = null;

  exports.run = function() {
    return load(function(err) {
      var options, parser, targets;
      if (err) {
        return printErr(err);
      }
      parser = new optparse.OptionParser(_switches);
      options = parser.parse(process.argv.slice(2));
      targets = options["arguments"];
      if (options.tasks) {
        targets.push("list_tasks");
      }
      if (targets.length === 0) {
        targets.push("build");
      }
      return invoke(targets, options, function(err) {
        if (err) {
          growl("Piefile\n" + (shortErr(err)));
          return printErr(err);
        }
      });
    });
  };

  load = function(cb) {
    option("-T", "--tasks", "List tasks");
    task("list_tasks", "Print out a list of tasks", function(options, cb) {
      _.each(_.sortBy(_tasks, function(t) {
        return t.name;
      }), function(t) {
        return console.log(_.sprintf("%-30s %s", "pie " + t.name, t.desc));
      });
      console.log("");
      _.each(_.sortBy(_switches, function(s) {
        return s[0];
      }), function(s) {
        return console.log(_.sprintf("%-30s %s", "  " + s[0] + ", " + s[1], s[2]));
      });
      console.log("");
      return cb(null);
    });
    task("build", "Build everything! (run all mappings, in the order defined)", runAllMappings);
    task("clean", "Clean everything! (remove the files generated by the mappings)", cleanAllMappings);
    task("watch", "Run a build, then start watching the filesystem for changes, triggering mappings as necessary", function(options, cb) {
      return invoke("build", options, function(err) {
        if (err) {
          return cb(err);
        }
        return watchMappings(options, cb);
      });
    });
    return evaluatePiefile(function(err) {
      var nStoreAlreadyFiredCallback;
      if (err) {
        return cb(err);
      }
      nStoreAlreadyFiredCallback = false;
      return _db = nStore["new"](".pie.db", (function(err) {
        if (!nStoreAlreadyFiredCallback) {
          nStoreAlreadyFiredCallback = true;
          return cb(err);
        }
      }));
    });
  };

  evaluatePiefile = function(cb) {
    return fs.readFile("Piefile", function(err, code) {
      if (err && err.code === "ENOENT") {
        return cb("No Piefile found. Please create one :)");
      }
      if (err) {
        return cb(err);
      }
      try {
        CoffeeScript.run(code.toString(), {
          filename: "Piefile"
        });
        return cb(null);
      } catch (err) {
        growl("Piefile\n" + (shortErr(err)));
        return printErr(err);
      }
    });
  };

  option = function() {
    var args;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return _switches.push(args);
  };

  task = function() {
    var args, name;
    name = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    return _tasks[name] = (function(func, args, ctor) {
      ctor.prototype = func.prototype;
      var child = new ctor, result = func.apply(child, args), t = typeof result;
      return t == "object" || t == "function" ? result || child : child;
    })(Task, [name].concat(__slice.call(args)), function(){});
  };

  invoke = function(name, options, cb) {
    var t;
    if (_.isArray(name)) {
      return async.forEachSeries(name, (function(name, innerCb) {
        return invoke(name, options, innerCb);
      }), cb);
    } else if (t = _tasks[name]) {
      return t.run(options, cb);
    } else {
      return cb("No task named \"" + name + "\" found");
    }
  };

  map = function() {
    var args, m, name;
    name = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    m = (function(func, args, ctor) {
      ctor.prototype = func.prototype;
      var child = new ctor, result = func.apply(child, args), t = typeof result;
      return t == "object" || t == "function" ? result || child : child;
    })(Mapping, [name].concat(__slice.call(args)), function(){});
    _mappings.push(m);
    return task(name, "Run " + name, function(options, cb) {
      return m.run(options, cb);
    });
  };

  watch = function(paths, options, eventHandler, cb) {
    var w;
    if (cb == null) {
      cb = noop;
    }
    w = new Watcher(paths, options, eventHandler);
    return w.start(function(err) {
      return cb(err, w);
    });
  };

  _.extend(global, {
    option: option,
    task: task,
    invoke: invoke,
    map: map,
    compilers: compilers,
    watch: watch
  });

  getMtime = function(file, cb) {
    return fs.stat(file, function(err, stats) {
      if (err) {
        return cb(err);
      }
      return cb(null, stats.mtime.getTime());
    });
  };

  printErr = function(err) {
    if (err) {
      if (err.stack != null) {
        return console.log(err.stack);
      } else {
        return console.log(shortErr(err));
      }
    }
  };

  shortErr = function(err) {
    if (err.message != null) {
      return err.message;
    } else {
      return err.toString();
    }
  };

  runAllMappings = function(options, cb) {
    return async.forEachSeries(_mappings, (function(m, innerCb) {
      return m.run(options, innerCb);
    }), function(err) {
      if (err) {
        return cb(err);
      }
      console.log("Build complete");
      growl("Build complete");
      return cb(null);
    });
  };

  rm = function(f, innerCb) {
    console.log("deleting", f);
    try {
      return fs.unlink(f, function(err) {
        if (err && err.code !== "ENOENT") {
          console.log(f, err);
        }
        return innerCb(null);
      });
    } catch (err) {
      if (err && err.code !== "ENOENT") {
        console.log(f, err);
      }
      return innerCb(null);
    }
  };

  cleanAllMappings = function(options, cb) {
    return async.map(_mappings, (function(m, innerCb) {
      return m.clean(innerCb);
    }), function(err) {
      if (err) {
        return cb(err);
      }
      return rm(".pie.db", cb);
    });
  };

  watchMappings = function(options, cb) {
    var toWatch;
    if (_mappingsWatcher) {
      _mappingsWatcher.stop();
    }
    toWatch = _.uniq(_.map(_.flatten(_.map(_mappings, function(m) {
      return m.src;
    })), function(p) {
      return p.replace(/\*\*.*$/, '').replace(/\*\..+$/, '').replace(/\/$/, '');
    }).sort());
    toWatch = _.filter(toWatch, function(s) {
      return _.all(toWatch, function(t) {
        return s === t || s.indexOf(t + "/") !== 0;
      });
    });
    console.log("Starting watcher");
    return _mappingsWatcher = watch(toWatch, {}, handleMappingWatchEvent, cb);
  };

  handleMappingWatchEvent = function(event) {
    var mappings, processMapping;
    path = event.name;
    console.log(path, event.isDelete() ? "was deleted" : "changed");
    mappings = _.filter(_mappings, function(m) {
      return m.matchesSrc(path);
    });
    processMapping = function(m, cb) {
      if (!(event.isDelete() && !m.batch)) {
        return m.runOnFiles([path], {}, cb);
      } else {
        return m.cleanForFiles([path], cb);
      }
    };
    return async.forEach(mappings, processMapping, printErr);
  };

  noop = function() {
    return null;
  };

  Task = (function() {

    function Task(name, desc, func) {
      this.name = name;
      this.desc = desc;
      this.func = func;
    }

    Task.prototype.run = function(options, cb) {
      try {
        return this.func(options, cb);
      } catch (err) {
        growl("" + this.name + "\n" + err);
        return cb(err);
      }
    };

    return Task;

  })();

  Mapping = (function() {

    function Mapping() {
      var args, dest, name, src;
      name = arguments[0], src = arguments[1], dest = arguments[2], args = 4 <= arguments.length ? __slice.call(arguments, 3) : [];
      this.name = name;
      this.src = src;
      this.dest = dest;
      this.calculateDest = __bind(this.calculateDest, this);

      this.hasChanged = __bind(this.hasChanged, this);

      this.clearMtime = __bind(this.clearMtime, this);

      this.updateMtime = __bind(this.updateMtime, this);

      if (args.length === 1) {
        this.func = args[0];
        this.options = {};
      } else if (args.length === 2) {
        this.func = args[1];
        this.options = args[0];
      }
      this.batch = this.options.batch;
    }

    Mapping.prototype.updateMtime = function(file, cb) {
      var _this = this;
      return getMtime(file, function(err, mtime) {
        if (err) {
          return cb(err);
        }
        return _db.save("" + _this.name + ":" + file, mtime, cb);
      });
    };

    Mapping.prototype.clearMtime = function(file, cb) {
      return _db.save("" + this.name + ":" + file, null, cb);
    };

    Mapping.prototype.hasChanged = function(file, cb) {
      return _db.get("" + this.name + ":" + file, function(err, prev) {
        if (!err && prev) {
          return getMtime(file, function(err, mtime) {
            if (err) {
              return cb(err);
            }
            return cb(mtime !== prev);
          });
        } else {
          return cb(true);
        }
      });
    };

    Mapping.prototype.findSrcFiles = function(cb) {
      if (_.isString(this.src)) {
        return glob(this.src, cb);
      } else if (_.isArray(this.src)) {
        return async.concat(this.src, glob, cb);
      } else {
        return cb("mapping src must be string or array of strings");
      }
    };

    Mapping.prototype.calculateDest = function(f) {
      if (_.isFunction(this.dest)) {
        return this.dest(f);
      } else {
        return this.dest;
      }
    };

    Mapping.prototype.outputFiles = function(cb) {
      var _this = this;
      return this.findSrcFiles(function(err, files) {
        if (err) {
          return cb(err);
        }
        return cb(null, _.uniq(_.flatten(_.map(files, _this.calculateDest))));
      });
    };

    Mapping.prototype.matchesSrc = function(file) {
      if (_.isString(this.src)) {
        return minimatch(file, this.src, {});
      } else if (_.isArray(this.src)) {
        return _.any(this.src, function(s) {
          return minimatch(file, s, {});
        });
      } else {
        throw "mapping src must be string or array of strings";
      }
    };

    Mapping.prototype.run = function(options, cb) {
      var _this = this;
      return this.findSrcFiles(function(err, files) {
        if (err) {
          return cb(err);
        }
        return _this.runOnFiles(files, options, cb);
      });
    };

    Mapping.prototype.runOnFiles = function(files, options, cb) {
      var _this = this;
      console.log("Running", this.name, "on", files.length, "files");
      return async.filter(files, this.hasChanged, function(changedFiles) {
        var unchangedFiles, x;
        unchangedFiles = _.without(files, changedFiles);
        if (_this.batch) {
          if (changedFiles.length > 0) {
            return _this.execFunc(changedFiles, options, function(err) {
              if (err) {
                growl("" + _this.name + "\n" + (shortErr(err)));
              }
              if (err) {
                return cb(err);
              }
              return async.forEach(changedFiles, _this.updateMtime, cb);
            });
          } else {
            return cb(null);
          }
        } else {
          if (changedFiles.length > 0) {
            x = function(f, innerCb) {
              return _this.execFunc(f, options, function(err) {
                if (err) {
                  growl("" + f + "\n" + (shortErr(err)));
                }
                if (err) {
                  return innerCb(err);
                }
                return _this.updateMtime(f, innerCb);
              });
            };
            return async.forEach(changedFiles, x, cb);
          } else {
            return cb(null);
          }
        }
      });
    };

    Mapping.prototype.execFunc = function(f, options, cb) {
      try {
        return this.func(f, this.calculateDest(f), options, cb);
      } catch (err) {
        return cb(err);
      }
    };

    Mapping.prototype.clean = function(cb) {
      var _this = this;
      return this.findSrcFiles(function(err, files) {
        if (err) {
          return cb(err);
        }
        return _this.cleanForFiles(files, cb);
      });
    };

    Mapping.prototype.cleanForFiles = function(srcFiles, cb) {
      var _this = this;
      return async.forEach(srcFiles, this.clearMtime, function(err) {
        var destFiles;
        if (err) {
          return cb(err);
        }
        destFiles = _.uniq(_.flatten(_.map(srcFiles, _this.calculateDest)));
        return async.forEach(destFiles, rm, cb);
      });
    };

    return Mapping;

  })();

  Watcher = (function() {

    function Watcher(paths, options, eventHandler) {
      this.paths = paths;
      this.options = options;
      this.eventHandler = eventHandler;
      this.watch = __bind(this.watch, this);

      this.watches = [];
      this.options || (this.options = {});
      this.options.exclude = (this.options.exclude || []).concat(/\.pie\.db$/, /\.DS_Store$/, /(^|\/)node_modules($|\/)/, /(^|\/)log($|\/)/, /(^|\/)tmp($|\/)/, /~$/, /\#$/, /\.\#.+$/, /\.swp$/, /\.lock$/, /~\.nib$/);
    }

    Watcher.prototype.start = function(cb) {
      if (cb == null) {
        cb = noop;
      }
      if (_.isArray(this.paths)) {
        return async.forEachSeries(this.paths, this.watch, cb);
      } else {
        return this.watch(this.paths, cb);
      }
    };

    Watcher.prototype.stop = function(cb) {
      if (cb == null) {
        cb = noop;
      }
      _.each(this.watches, function(w) {
        return w.end();
      });
      return cb(null);
    };

    Watcher.prototype.watch = function(path, cb) {
      var _this = this;
      return fs.stat(path, function(err, stats) {
        if (err) {
          return cb(err);
        }
        if (stats.isFile()) {
          console.log("Watching", path);
          _this.watches.push(_this.watchFile(path));
          return cb(null);
        } else if (stats.isDirectory()) {
          console.log("Watching", path);
          _this.watches.push(_this.watchDir(path));
          return cb(null);
        } else {
          return cb("Don't know how to watch " + path + ", as it isn't a file or a directory");
        }
      });
    };

    Watcher.prototype.watchDir = function(path) {
      return fsWatchTree.watchTree(path, this.options, this.eventHandler);
    };

    Watcher.prototype.watchFile = function(path) {
      var issueChange, issueDelete, w,
        _this = this;
      issueChange = function() {
        return _this.eventHandler({
          isMkdir: function() {
            return false;
          },
          isDelete: function() {
            return false;
          },
          isModify: function() {
            return true;
          },
          isDirectory: function() {
            return false;
          },
          name: path
        });
      };
      issueDelete = function() {
        return _this.eventHandler({
          isMkdir: function() {
            return false;
          },
          isDelete: function() {
            return true;
          },
          isModify: function() {
            return false;
          },
          isDirectory: function() {
            return false;
          },
          name: path
        });
      };
      w = fs.watch(path, function(event) {
        var _this = this;
        if (event === "change") {
          return issueChange();
        } else if (event === "rename") {
          return fs.exists(path, function(exists) {
            if (exists) {
              return issueChange();
            } else {
              return issueDelete();
            }
          });
        }
      });
      return {
        end: function() {
          return w.close();
        }
      };
    };

    return Watcher;

  })();

}).call(this);
