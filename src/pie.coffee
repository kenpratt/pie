fs            = require "node-fs"
path          = require "path"
util          = require "util"
async         = require "async"
CoffeeScript  = require "coffee-script"
glob          = require "glob"
minimatch     = require "minimatch"
fsWatchTree   = require "fs-watch-tree"
nStore        = require "nstore"
growl         = require "growl"
compilers     = require "./compilers"
optparse      = require "./optparse"
_             = require "underscore"


_switches = []
_tasks = {}
_mappings = []
_mappingsWatcher = null
_db = null


# the entry point (called from bin/pie)
exports.run = () ->
  load (err) ->
    return printErr(err) if err
    parser = new optparse.OptionParser(_switches)
    options = parser.parse(process.argv[2..])
    targets = options.arguments
    targets.push("list_tasks") if options.tasks
    targets.push("build") if targets.length == 0
    invoke targets, options, (err) ->
      if err
        growl("Piefile\n#{shortErr(err)}")
        printErr(err)

# bootstrap
load = (cb) ->
  option "-T", "--tasks", "List tasks"

  task "list_tasks", "Print out a list of tasks", (options, cb) ->
    _.each _.sortBy(_tasks, (t) -> t.name),
           (t) -> console.log _.sprintf("%-30s %s", "pie #{t.name}", t.desc)
    console.log ""
    _.each _.sortBy(_switches, (s) -> s[0]),
           (s) -> console.log _.sprintf("%-30s %s", "  #{s[0]}, #{s[1]}", s[2])
    console.log ""
    cb(null)

  # define a few default tasks
  task "build", "Build everything! (run all mappings, in the order defined)", runAllMappings

  task "clean", "Clean everything! (remove the files generated by the mappings)", cleanAllMappings

  task "watch", "Run a build, then start watching the filesystem for changes, triggering mappings as necessary", (options, cb) ->
    invoke "build", options, (err) ->
      return cb(err) if err
      watchMappings(options, cb)

  # slurp up the Piefile (can override the default tasks if it wants)
  evaluatePiefile (err) ->
    return cb(err) if err
    reloadDB(cb)

evaluatePiefile = (cb) ->
  fs.readFile "Piefile", (err, code) ->
    return cb("No Piefile found. Please create one :)") if err && err.code == "ENOENT"
    return cb(err) if err
    try
      CoffeeScript.run(code.toString(), { filename: "Piefile" })
      cb(null)
    catch err
      growl("Piefile\n#{shortErr(err)}")
      printErr(err)

option = (args...) ->
  _switches.push(args)

task = (name, args...) ->
  _tasks[name] = new Task(name, args...)

invoke = (name, options, cb) ->
  if _.isArray(name)
    async.forEachSeries(name, ((name, innerCb) -> invoke(name, options, innerCb)), cb)
  else if t = _tasks[name]
    t.run(options, cb)
  else
    cb("No task named \"#{name}\" found")

map = (name, args...) ->
  m = new Mapping(name, args...)
  _mappings.push(m)
  task name, "Run #{name}", (options, cb) -> m.run(options, cb)

watch = (paths, options, eventHandler, cb = noop) ->
  w = new Watcher(paths, options, eventHandler)
  w.start (err) -> cb(err, w)

reloadDB = (cb) ->
  nStoreAlreadyFiredCallback = false
  _db = nStore.new ".pie.db", (err) ->
    if !nStoreAlreadyFiredCallback
      nStoreAlreadyFiredCallback = true
      cb(err)

# exports, available in global namespace of Piefile
_.extend(global, { option: option, task: task, invoke: invoke, map: map, compilers: compilers, watch: watch, reloadDB: reloadDB })

getMtime = (file, cb) ->
  fs.stat file, (err, stats) ->
    return cb(err) if err
    cb(null, stats.mtime.getTime())

printErr = (err) ->
  if err
    if err.stack?
      console.log(err.stack)
    else
      console.log(shortErr(err))

shortErr = (err) ->
  if err.message?
    err.message
  else
    err.toString()

runAllMappings = (options, cb) ->
  async.forEachSeries _mappings, ((m, innerCb) -> m.run(options, innerCb)), (err) ->
    return cb(err) if err
    console.log "Build complete"
    growl "Build complete"
    cb(null)

rm = (f, innerCb) ->
  console.log "deleting", f
  try
    fs.unlink f, (err) ->
      console.log(f, err) if err && err.code != "ENOENT"
      innerCb(null)
  catch err
    console.log(f, err) if err && err.code != "ENOENT"
    innerCb(null)

cleanAllMappings = (options, cb) ->
  async.map _mappings, ((m, innerCb) -> m.clean(innerCb)), (err) ->
    return cb(err) if err
    rm ".pie.db", cb

watchMappings = (options, cb) ->
  _mappingsWatcher.stop() if _mappingsWatcher

  # calculate watch targets
  toWatch = _.uniq(_.map(_.flatten(_.map(_mappings, (m) -> m.src)), (p) -> p.replace(/\*\*.*$/, '').replace(/\*\..+$/, '').replace(/\/$/, '')).sort())
  toWatch = _.filter(toWatch, (s) -> _.all(toWatch, (t) -> s == t or s.indexOf(t + "/") != 0))

  console.log "Starting watcher"
  _mappingsWatcher = watch(toWatch, {}, handleMappingWatchEvent, cb)

handleMappingWatchEvent = (event) ->
  path = event.name
  console.log path, if event.isDelete() then "was deleted" else "changed"
  mappings = _.filter(_mappings, (m) -> m.matchesSrc(path))

  processMapping = (m, cb) ->
    unless event.isDelete() and !m.batch
      # run mapping on non-deletes, or if it's a deleted file in a batch mapping
      m.runOnFiles([path], {}, cb)
    else
      # on a delete in non-batched mapping, delete the output file(s)
      m.cleanForFiles([path], cb)

  async.forEach mappings, processMapping, printErr

noop = () -> null


# just a lil' bit o' code
class Task
  constructor: (@name, @desc, @func) ->

  run: (options, cb) ->
    try
      @func(options, cb)
    catch err
      growl "#{@name}\n#{err}"
      cb(err)


# represents a mapping / build target
# stores mtimes of source files so it can be smart later. mtimes are stored scoped
# to each mapping, so that the same source files can be used in multiple mappings.
class Mapping
  constructor: (@name, @src, @dest, args...) ->
    if args.length == 1
      @func = args[0]
      @options = {}
    else if args.length == 2
      @func = args[1]
      @options = args[0]
    @batch = @options.batch

  updateMtime: (file, cb) =>
    getMtime file, (err, mtime) =>
      return cb(err) if err
      _db.save("#{@name}:#{file}", mtime, cb)

  clearMtime: (file, cb) =>
    _db.save("#{@name}:#{file}", null, cb)

  hasChanged: (file, cb) =>
    _db.get "#{@name}:#{file}", (err, prev) ->
      if !err && prev
        getMtime file, (err, mtime) ->
          return cb(err) if err
          cb(mtime != prev)
      else
        cb(true)

  findSrcFiles: (cb) ->
    if _.isString(@src)
      glob(@src, cb)
    else if _.isArray(@src)
      async.concat(@src, glob, cb)
    else
      cb("mapping src must be string or array of strings")

  calculateDest: (f) =>
    if _.isFunction(@dest)
      @dest(f)
    else
      @dest

  outputFiles: (cb) ->
    @findSrcFiles (err, files) =>
      return cb(err) if err
      cb(null, _.uniq(_.flatten(_.map(files, @calculateDest))))

  matchesSrc: (file) ->
    if _.isString(@src)
      minimatch(file, @src, {})
    else if _.isArray(@src)
      _.any @src, (s) -> minimatch(file, s, {})
    else
      throw "mapping src must be string or array of strings"

  run: (options, cb) ->
    @findSrcFiles (err, files) =>
      return cb(err) if err
      @runOnFiles(files, options, cb)

  runOnFiles: (files, options, cb) ->
    console.log "Running", @name, "on", files.length, "files"
    async.filter files, @hasChanged, (changedFiles) =>
      unchangedFiles = _.without(files, changedFiles)

      if @batch
        if changedFiles.length > 0
          @execFunc changedFiles, options, (err) =>
            growl("#{@name}\n#{shortErr(err)}") if err
            return cb(err) if err
            async.forEach changedFiles, @updateMtime, cb
        else
          cb(null)
      else
        if changedFiles.length > 0
          x = (f, innerCb) =>
            @execFunc f, options, (err) =>
              growl("#{f}\n#{shortErr(err)}") if err
              return innerCb(err) if err
              @updateMtime(f, innerCb)
          async.forEach changedFiles, x, cb
        else
          cb(null)

  execFunc: (f, options, cb) ->
    try
      @func(f, @calculateDest(f), options, cb)
    catch err
      cb(err)

  clean: (cb) ->
    @findSrcFiles (err, files) =>
      return cb(err) if err
      @cleanForFiles(files, cb)

  cleanForFiles: (srcFiles, cb) ->
    async.forEach srcFiles, @clearMtime, (err) =>
      return cb(err) if err
      destFiles = _.uniq(_.flatten(_.map(srcFiles, @calculateDest)))
      async.forEach destFiles, rm, cb


# watch one or more files or directory trees, and call eventHandler if anything
# changes (or is added or removed)
class Watcher
  constructor: (@paths, @options, @eventHandler) ->
    @watches = []
    @options ||= {}
    @options.exclude = (@options.exclude || []).concat(/\.pie\.db$/, /\.DS_Store$/, /(^|\/)node_modules($|\/)/, /(^|\/)log($|\/)/, /(^|\/)tmp($|\/)/, /~$/, /\#$/, /\.\#.+$/, /\.swp$/, /\.lock$/, /~\.nib$/)

  start: (cb = noop) ->
    if _.isArray(@paths)
      async.forEachSeries(@paths, @watch, cb)
    else
      @watch(@paths, cb)

  stop: (cb = noop) ->
    _.each @watches, (w) -> w.end()
    cb(null)

  watch: (path, cb) =>
    fs.stat path, (err, stats) =>
      return cb(err) if err
      if stats.isFile()
        console.log "Watching", path
        @watches.push @watchFile(path)
        cb(null)
      else if stats.isDirectory()
        console.log "Watching", path
        @watches.push @watchDir(path)
        cb(null)
      else
        cb("Don't know how to watch #{path}, as it isn't a file or a directory")

  # watch a directory tree
  watchDir: (path) ->
    fsWatchTree.watchTree(path, @options, @eventHandler)

  # watch a single file, but call handler with event like fs-watch-tree
  watchFile: (path) ->
    issueChange = () =>
      @eventHandler
        isMkdir: () -> false
        isDelete: () -> false
        isModify: () -> true
        isDirectory: () -> false
        name: path
    issueDelete = () =>
      @eventHandler
        isMkdir: () -> false
        isDelete: () -> true
        isModify: () -> false
        isDirectory: () -> false
        name: path
    w = fs.watch path, (event) ->
      if event == "change"
        issueChange()
      else if event == "rename"
        fs.exists path, (exists) =>
          if exists
            issueChange()
          else
            issueDelete()
    { end: () -> w.close() }
